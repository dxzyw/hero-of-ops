## Prometheus
- Prometheus的工作流程
- Metric的几种类型？分别是什么？ ☆
- Prometheus有哪几种服务发现☆
- Prometheus常用函数
- thanos架构☆
- thanos与VictoriaMetrics对比
- thanos sidecar和receive区别☆
- thanos rule组件和prometheus区别
- Prometheus告警从触发到收到通知延迟在哪
- 告警抑制怎么做☆
- 告警架构高可用怎么做☆
- Pod指标WSS和RSS区别☆
- 监控四个黄金指标
- 在大规模环境下，如何优化Prometheus性能
- 如何实现告警的自动化响应☆
- Prometheus数据压缩和持久化实现原理
- kubectl top输出与Linux free命令不一致原因☆
- 用到了哪些exporter，功能是什么
- 是否自己开发过exporter☆
- target down的情况如何进行故障排除？
- Exporter 停止工作，如何监控？
- Prometheus的拉取模式与zabbix推送模式有何区别？各有什么优缺点？
- Prometheus operator怎么添加targets和告警规则
- k8s集群外exporter怎么使用Prometheus监控


## Prometheus 进阶
- Prometheus的数据模型是什么？如何组织和存储时序数据？
- Prometheus如何处理高基数问题？
- remote write和remote read的工作原理是什么？
- 如何实现Prometheus的跨数据中心监控？
- Prometheus的查询语言PromQL有哪些优势和局限性？
- 如何优化Prometheus的查询性能？
- Prometheus如何实现标签的动态重写（relabel）？
- 如何处理Prometheus采集数据丢失的情况？
- Prometheus的数据保留策略如何设置？
- recording rules和alerting rules的区别和使用场景

## 监控系统设计
- 如何设计一个大规模监控系统的架构？
- 监控系统的性能指标有哪些？如何衡量？
- 监控数据的采集频率如何确定？
- 如何处理监控数据的时间戳对齐问题？
- 监控系统中如何处理敏感数据？
- 如何实现监控指标的动态聚合？

## 告警管理
- 如何避免告警风暴？
- 告警级别如何划分？
- 如何设计合理的告警阈值？
- 告警收敛策略有哪些？
- 如何处理告警误报？
- 告警升级机制如何设计？
- 如何实现告警的分组和路由？
- 告警恢复通知的策略是什么？

## 可观测性
- 可观测性的三大支柱是什么？
- 如何实现分布式追踪？
- 日志、指标、追踪三者之间的关系？
- 如何选择合适的可观测性工具？
- APM系统的核心功能有哪些？
- 如何实现服务依赖关系的可视化？
- 如何衡量系统的可观测性水平？
- ELK Stack在可观测性中的应用？
- SLI、SLO、SLA的区别和关系？
- 如何实现全链路监控？

## 性能监控
- 如何监控系统的性能瓶颈？
- 常见的性能问题诊断工具有哪些？
- 如何进行容器性能监控？
- 微服务架构下的性能监控策略？
- 如何监控数据库性能？
- JVM性能监控的关键指标有哪些？
- 网络性能监控的方法和工具？
- 如何监控云服务的性能？
- 性能监控数据的可视化方案？
- 如何设置性能基准线？

## Prometheus

### Prometheus的工作流程
1. 通过Pull模式从配置的targets拉取metrics数据
2. 将采集到的数据存储在本地时序数据库(TSDB)
3. 根据配置的规则(recording rules和alerting rules)对数据进行计算和告警判断
4. 通过API提供数据查询服务，支持PromQL查询语言
5. 通过Alertmanager处理和分发告警

### Metric的几种类型
1. Counter（计数器）
   - 只增不减的计数器
   - 常用于记录请求数、错误数等累计值
   
2. Gauge（仪表盘）
   - 可增可减的数值
   - 常用于记录温度、内存使用量等即时值

3. Histogram（直方图）
   - 对观察值进行采样，并按配置的桶(bucket)记录值的分布情况
   - 包含_count、_sum、_bucket等指标
   - 常用于请求延迟、响应大小的分布统计

4. Summary（摘要）
   - 类似Histogram，但直接存储分位数
   - 包含_count、_sum和quantile值
   - 计算在客户端进行，服务端不能再进行聚合计算

### Prometheus服务发现机制
1. 静态配置（static_configs）
   - 直接在配置文件中指定目标

2. 基于文件的服务发现（file_sd_configs）
   - 通过JSON或YAML文件定义目标

3. Kubernetes服务发现
   - kubernetes_sd_configs
   - 支持多种角色：node、service、pod、endpoints、ingress

4. 云平台服务发现
   - AWS EC2
   - Azure
   - GCP
   - OpenStack等

### Prometheus常用函数
1. 聚合函数
   - sum()：求和
   - avg()：平均值
   - max()/min()：最大/最小值
   - count()：计数

2. 时间函数
   - rate()：计算每秒平均增长率
   - irate()：计算瞬时增长率
   - increase()：指定时间范围内的增量

3. 运算函数
   - abs()：绝对值
   - ceil()/floor()：向上/向下取整
   - round()：四舍五入

4. 预测函数
   - predict_linear()：线性预测
   - deriv()：导数计算

### Thanos架构
1. 核心组件：
   - Sidecar：连接Prometheus，上传数据到对象存储
   - Store Gateway：访问对象存储中的历史数据
   - Querier：查询整合数据
   - Compactor：压缩历史数据
   - Ruler：执行告警规则
   - Receive：接收远程写入的数据

2. 主要特性：
   - 全局查询视图
   - 长期存储
   - 高可用性
   - 降低存储成本

### Thanos与VictoriaMetrics对比
1. Thanos优势：
   - Prometheus生态完全兼容
   - 分布式查询能力强
   - 社区活跃度高

2. VictoriaMetrics优势：
   - 资源占用更少
   - 查询性能更好
   - 部署维护更简单
   - 存储效率更高

### Thanos Sidecar和Receive区别
1. Sidecar：
   - 部署在Prometheus旁边
   - 读取本地TSDB数据
   - 上传到对象存储
   - 提供Store API查询接口

2. Receive：
   - 独立组件
   - 接收远程写入的数据
   - 本地存储数据
   - 提供Store API查询接口

### Thanos Rule组件和Prometheus区别
1. Thanos Rule：
   - 支持全局视图的规则评估
   - 可以访问所有数据源
   - 规则结果可以写入对象存储
   - 适合全局告警规则

2. Prometheus Rule：
   - 只能评估本地数据
   - 规则结果存储在本地
   - 适合本地告警规则

### Prometheus告警延迟原因
1. 数据采集间隔
2. 规则评估间隔
3. Alertmanager处理时间
4. 通知渠道延迟
5. 网络延迟

### 告警抑制实现
1. 配置方式：
   - Alertmanager配置文件中定义inhibit_rules
   - 基于标签匹配规则
   
2. 常见场景：
   - 集群故障时抑制节点告警
   - 父服务故障时抑制子服务告警

### 告警高可用实现
1. Prometheus高可用：
   - 部署多个Prometheus实例
   - 使用不同的采集目标或联邦集群

2. Alertmanager高可用：
   - 部署多个Alertmanager实例
   - 配置集群模式
   - 使用gossip协议同步告警状态

### Pod指标WSS和RSS区别
1. WSS (Working Set Size)：
   - 实际使用的物理内存
   - 包含最近访问的内存页面
   - 更准确反映应用内存需求

2. RSS (Resident Set Size)：
   - 进程占用的物理内存总量
   - 包含共享库内存
   - 可能高估实际内存使用

### 监控四个黄金指标
1. 延迟 (Latency)
   - 服务响应时间
   - 各种分位数统计

2. 流量 (Traffic)
   - 系统负载指标
   - 请求量/带宽等

3. 错误 (Errors)
   - 失败请求数
   - 错误率统计

4. 饱和度 (Saturation)
   - 系统资源使用率
   - 容量预测指标

### 大规模环境下Prometheus性能优化
1. 采集优化：
   - 合理设置采集间隔
   - 优化target数量
   - 使用联邦集群分片

2. 存储优化：
   - 使用远程存储
   - 优化保留期限
   - 使用压缩算法

3. 查询优化：
   - 优化PromQL查询
   - 使用记录规则预计算
   - 实现查询缓存

### 告警自动化响应实现
1. 技术方案：
   - Webhook接收告警
   - 自动化脚本处理
   - 与ITSM系统集成
   
2. 常见场景：
   - 自动扩容
   - 服务重启
   - 故障自愈

### Prometheus数据压缩和持久化原理
1. 数据压缩：
   - 使用Gorilla压缩算法
   - 针对时间序列特点优化
   - 支持增量压缩

2. 持久化实现：
   - 基于本地TSDB
   - 块存储模型
   - WAL日志保证一致性

### kubectl top与free命令不一致原因
1. 计算方式不同：
   - kubectl top基于cgroup统计
   - free命令读取/proc/meminfo

2. 统计范围不同：
   - kubectl top只统计容器内存
   - free统计整个系统内存

3. 更新频率不同：
   - metrics-server采集延迟
   - free实时读取

### 常用Exporter及功能
1. node_exporter：
   - 系统指标采集
   - 硬件状态监控

2. blackbox_exporter：
   - HTTP/HTTPS探测
   - TCP/ICMP检查

3. mysql_exporter：
   - MySQL性能指标
   - 数据库状态监控

4. redis_exporter：
   - Redis性能指标
   - 键值统计信息

### 自定义Exporter开发要点
1. 技术选择：
   - 官方SDK支持
   - 遵循Prometheus指标规范

2. 关键考虑：
   - 性能影响
   - 指标合理性
   - 错误处理

### Target Down故障排查
1. 检查项：
   - 网络连通性
   - 端口可访问性
   - 认证配置
   - 服务发现配置

2. 排查工具：
   - curl测试
   - tcpdump抓包
   - 日志分析

### Exporter监控方案
1. 健康检查：
   - 配置up指标告警
   - 监控进程状态
   - 端口可用性检查

2. 双向监控：
   - Prometheus监控Exporter
   - 外部监控系统备份

### Prometheus拉取vs Zabbix推送模式
1. Prometheus拉取模式优势：
   - 中心节点控制采集
   - 简单可靠
   - 便于调试

2. Zabbix推送模式优势：
   - 更灵活的防火墙配置
   - 适合动态环境
   - 可控制数据发送时机

### Prometheus Operator管理
1. 添加targets：
   - 创建ServiceMonitor
   - 配置PodMonitor
   - 使用Probe资源

2. 配置告警规则：
   - 创建PrometheusRule
   - 使用RuleGroup组织规则
   - 支持动态更新

### 集群外Exporter监控方案
1. 直接访问：
   - 配置网络访问
   - 使用NodePort/LoadBalancer

2. 代理方式：
   - 使用反向代理
   - 部署边缘节点采集

3. 联邦集群：
   - 部署边缘Prometheus
   - 通过联邦采集汇总
## Prometheus 进阶

### Prometheus的数据模型
1. 基本结构：
   - 时序数据（Time Series）
   - 每个时序由指标名称和标签集唯一标识
   - 样本包含时间戳和值

2. 存储格式：
   - 使用自定义的TSDB引擎
   - 按2小时为单位分块存储
   - 块内数据按时间顺序存储
   - 使用倒排索引加速标签查询

### 高基数问题处理
1. 预防措施：
   - 合理设计标签
   - 避免动态标签值
   - 限制标签数量

2. 优化方案：
   - 使用recording rules预聚合
   - 实施标签过滤
   - 采用分片架构
   - 使用VictoriaMetrics等替代存储

### Remote Write/Read工作原理
1. Remote Write：
   - 将采集的样本并行写入远程存储
   - 使用队列缓冲
   - 支持失败重试
   - 可配置多个目标端点

2. Remote Read：
   - 按需从远程存储读取数据
   - 支持数据过滤
   - 可配置读取时间范围
   - 本地缓存优化

### 跨数据中心监控实现
1. 联邦集群方案：
   - 在每个数据中心部署Prometheus
   - 使用中心Prometheus汇总数据
   - 配置适当的采集间隔

2. 远程存储方案：
   - 统一的远程存储系统
   - 各数据中心使用Remote Write
   - 中心查询服务统一访问

### PromQL特性
1. 优势：
   - 强大的聚合能力
   - 丰富的内置函数
   - 支持标签匹配
   - 灵活的时间序列选择

2. 局限性：
   - 不支持子查询优化
   - 复杂查询性能较差
   - 缺乏窗口函数
   - JOIN能力有限

### 查询性能优化
1. 查询层面：
   - 使用精确的标签匹配
   - 避免使用正则表达式
   - 限制时间范围
   - 使用recording rules

2. 系统层面：
   - 优化存储
   - 增加缓存
   - 使用查询负载均衡
   - 实施查询超时限制

### 标签动态重写（Relabel）
1. 配置方式：
   - relabel_configs
   - metric_relabel_configs

2. 常用操作：
   - replace：替换标签值
   - keep：保留匹配的目标
   - drop：删除匹配的目标
   - labelmap：复制标签
   - hashmod：哈希取模

### 数据丢失处理
1. 预防措施：
   - 配置适当的存储容量
   - 使用远程存储备份
   - 实施高可用部署
   - 监控采集状态

2. 恢复方案：
   - 使用备份数据恢复
   - 配置数据保留策略
   - 实施数据补采集
   - 使用插值处理

### 数据保留策略设置
1. 配置参数：
   - storage.tsdb.retention.time
   - storage.tsdb.retention.size

2. 考虑因素：
   - 存储容量
   - 查询需求
   - 数据价值
   - 合规要求

### Recording Rules vs Alerting Rules
1. Recording Rules：
   - 预计算和存储表达式结果
   - 优化查询性能
   - 简化复杂查询
   - 用于频繁访问的指标

2. Alerting Rules：
   - 定义告警条件
   - 生成告警事件
   - 支持模板化
   - 集成告警通知

## 监控系统设计

### 大规模监控系统架构设计
1. 核心组件：
   - 数据采集层
   - 数据存储层
   - 查询服务层
   - 告警处理层
   - 展示交互层

2. 设计原则：
   - 高可用性
   - 可扩展性
   - 容错性
   - 性能优化

### 监控系统性能指标
1. 系统指标：
   - 数据采集延迟
   - 查询响应时间
   - 存储写入速率
   - 资源使用率

2. 业务指标：
   - 采集覆盖率
   - 告警准确率
   - 数据完整性
   - 系统可用性

### 采集频率确定
1. 考虑因素：
   - 监控对象特性
   - 数据价值周期
   - 存储成本
   - 系统负载

2. 建议策略：
   - 关键指标高频采集
   - 一般指标适中频率
   - 长期趋势低频采集
   - 动态调整能力

### 时间戳对齐处理
1. 常见问题：
   - 采集延迟
   - 时钟不同步
   - 数据乱序

2. 解决方案：
   - NTP时间同步
   - 时间窗口对齐
   - 延迟数据处理
   - 时间戳规范化

### 敏感数据处理
1. 安全措施：
   - 数据脱敏
   - 访问控制
   - 传输加密
   - 审计日志

2. 实施方案：
   - 标签过滤
   - 指标重命名
   - 权限分级
   - 数据分区

### 监控指标动态聚合
1. 实现方式：
   - 使用recording rules
   - 标签聚合
   - 时间窗口聚合
   - 动态计算

2. 应用场景：
   - 多维度分析
   - 趋势计算
   - 容量规划
   - 成本分析
  
  ## 告警管理

### 避免告警风暴
1. 预防措施：
   - 设置合理的告警阈值
   - 实施告警分级
   - 配置告警抑制规则
   - 使用告警收敛策略

2. 处理方法：
   - 告警聚合
   - 时间窗口限制
   - 智能去重
   - 动态阈值调整

### 告警级别划分
1. P0/Critical：
   - 严重业务中断
   - 数据丢失风险
   - 需要立即处理

2. P1/High：
   - 服务性能严重下降
   - 部分功能不可用
   - 需要紧急处理

3. P2/Medium：
   - 性能轻微下降
   - 非核心功能异常
   - 需要计划处理

4. P3/Low：
   - 潜在风险提醒
   - 优化建议
   - 可延后处理

### 告警阈值设计
1. 设计原则：
   - 基于历史数据分析
   - 考虑业务特点
   - 动态调整能力
   - 多级阈值设置

2. 实施方法：
   - 基线分析
   - 趋势预测
   - 季节性调整
   - 异常检测算法

### 告警收敛策略
1. 时间维度：
   - 周期性抑制
   - 持续时间判断
   - 静默期设置

2. 空间维度：
   - 相似告警合并
   - 关联告警处理
   - 重复告警过滤

### 告警误报处理
1. 预防措施：
   - 优化告警规则
   - 增加确认机制
   - 使用机器学习识别

2. 处理流程：
   - 误报分析
   - 规则调整
   - 监控优化
   - 反馈机制

### 告警升级机制
1. 时间维度升级：
   - 未处理时间超限
   - 问题持续恶化
   - 多次重复发生

2. 层级升级：
   - 运维团队
   - 技术主管
   - 业务负责人
   - 高层管理者

### 告警分组和路由
1. 分组策略：
   - 按服务分组
   - 按区域分组
   - 按级别分组
   - 按团队分组

2. 路由规则：
   - 标签匹配
   - 时间策略
   - 负载均衡
   - 值班轮询

### 告警恢复通知
1. 通知策略：
   - 即时通知
   - 批量通知
   - 状态变更通知
   - 摘要通知

2. 实现方式：
   - 自动恢复确认
   - 手动确认机制
   - 延迟通知
   - 通知级别区分

## 可观测性

### 可观测性三大支柱
1. 日志（Logs）：
   - 详细的事件记录
   - 问题排查依据
   - 审计追踪

2. 指标（Metrics）：
   - 系统性能数据
   - 业务指标统计
   - 趋势分析

3. 追踪（Traces）：
   - 分布式调用链
   - 性能瓶颈分析
   - 依赖关系图

### 分布式追踪实现
1. 技术选型：
   - Jaeger
   - Zipkin
   - SkyWalking
   - OpenTelemetry

2. 实现要点：
   - 统一TraceID
   - 采样策略
   - 上下文传递
   - 性能开销控制

### 日志、指标、追踪关系
1. 相互补充：
   - 日志提供详细上下文
   - 指标反映系统状态
   - 追踪展示调用关系

2. 协同使用：
   - 问题定位
   - 性能优化
   - 系统监控
   - 故障分析

### 可观测性工具选择
1. 选择标准：
   - 系统规模
   - 技术栈适配
   - 运维成本
   - 社区活跃度

2. 常用工具：
   - Prometheus + Grafana
   - ELK Stack
   - SkyWalking
   - Datadog

### APM系统核心功能
1. 应用性能：
   - 响应时间监控
   - 吞吐量统计
   - 错误率分析
   - 资源使用监控

2. 业务监控：
   - 用户体验
   - 业务指标
   - 异常监控
   - 依赖分析

### 服务依赖可视化
1. 实现方式：
   - 服务拓扑图
   - 调用链分析
   - 热点图展示
   - 流量可视化

2. 关键特性：
   - 实时更新
   - 交互式操作
   - 多维度展示
   - 异常标记

### 可观测性水平衡量
1. 定量指标：
   - 监控覆盖率
   - 问题发现时间
   - 故障解决时间
   - 服务可用性

2. 定性指标：
   - 问题定位能力
   - 故障预防能力
   - 系统理解度
   - 运维效率

### ELK Stack应用
1. 核心组件：
   - Elasticsearch：存储和检索
   - Logstash：日志收集和处理
   - Kibana：数据可视化
   - Beats：轻量级采集器

2. 应用场景：
   - 日志集中管理
   - 性能监控
   - 安全分析
   - 业务统计

### SLI、SLO、SLA区别
1. SLI（Service Level Indicator）：
   - 服务水平指标
   - 具体可测量的指标
   - 如响应时间、可用性

2. SLO（Service Level Objective）：
   - 服务水平目标
   - 对SLI的目标值
   - 内部质量目标

3. SLA（Service Level Agreement）：
   - 服务水平协议
   - 对外承诺指标
   - 包含违约责任

### 全链路监控实现
1. 监控范围：
   - 前端性能
   - 后端服务
   - 中间件
   - 基础设施

2. 实现方案：
   - 统一监控平台
   - 分布式追踪
   - 日志聚合
   - 性能分析

## 性能监控

### 系统性能瓶颈监控
1. 监控维度：
   - CPU使用率
   - 内存占用
   - 磁盘I/O
   - 网络带宽
   - 线程状态

2. 分析方法：
   - 性能曲线分析
   - 资源使用趋势
   - 瓶颈定位
   - 容量规划

### 性能诊断工具
1. 系统工具：
   - top/htop
   - vmstat
   - iostat
   - netstat
   - perf

2. 应用工具：
   - Arthas
   - JProfiler
   - YourKit
   - New Relic

### 容器性能监控
1. 监控指标：
   - 容器资源使用
   - 镜像状态
   - 网络性能
   - 存储性能

2. 工具选择：
   - cAdvisor
   - Prometheus
   - Datadog
   - Dynatrace

### 微服务性能监控
1. 关注点：
   - 服务调用链
   - 接口响应时间
   - 错误率统计
   - 资源使用效率

2. 监控策略：
   - 服务网格监控
   - API网关监控
   - 容器监控
   - 日志分析

### 数据库性能监控
1. 核心指标：
   - QPS/TPS
   - 连接数
   - 慢查询
   - 缓存命中率
   - 锁等待

2. 监控工具：
   - Prometheus
   - PMM
   - Datadog
   - Oracle Enterprise Manager

### JVM性能监控
1. 关键指标：
   - 堆内存使用
   - GC情况
   - 线程状态
   - 类加载
   - CPU使用

2. 监控工具：
   - JMX
   - VisualVM
   - Arthas
   - JProfiler

### 网络性能监控
1. 监控指标：
   - 带宽使用
   - 延迟
   - 丢包率
   - 连接状态

2. 工具方案：
   - Smokeping
   - Nagios
   - PRTG
   - Zabbix

### 云服务性能监控
1. 监控维度：
   - 资源使用率
   - 服务可用性
   - 成本效率
   - 安全状态

2. 工具选择：
   - AWS CloudWatch
   - Azure Monitor
   - Google Cloud Monitoring
   - 阿里云监控

### 性能监控可视化
1. 展示方式：
   - 仪表盘
   - 趋势图
   - 热力图
   - 拓扑图

2. 工具选择：
   - Grafana
   - Kibana
   - Datadog
   - Dynatrace

### 性能基准线设置
1. 设置方法：
   - 历史数据分析
   - 压力测试结果
   - 业务需求对标
   - 行业标准参考

2. 更新维护：
   - 定期评估
   - 动态调整
   - 异常复查
   - 持续优化